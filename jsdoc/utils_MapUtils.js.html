<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/MapUtils.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/MapUtils.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// @flow

import L from 'leaflet';
import Leaflet from 'leaflet';
import swal from 'sweetalert';
import 'leaflet-easybutton';
import _ from 'lodash';

import * as WaypointActionCreator from 'js/actions/WaypointActionCreator';
import geolib from 'geolib';
import { mToFt, decround } from 'js/utils/ComponentUtils';

/**
 * @module utils/MapUtils
 */

var map;
let dragging = false;
let rulerActive = false;
let rulerStart = null;
function setMap() {
  map = Leaflet.map('map').setZoom(17);
}

let planeMarker;
let offAxisMarker; 
function setMarkers() {
  planeMarker = L.marker([0,0], {icon: planeIconW}).addTo(map);
  offAxisMarker = L.marker([0,0], {icon: offAxisIcon}).addTo(map);
}

var waypointPath;
var planePath;
function setPaths() {
  waypointPath = Leaflet.polyline([], {color: 'purple'}).addTo(map);
  planePath = Leaflet.polyline([], {color: 'orange', dashArray: '5,15'}).addTo(map);
}

///////////////Plane Icons//////////////////

var offAxisIconHidden = L.icon({
  iconUrl: './img/markers/offAxisMarker.png',
  iconSize: [1, 1]
});

var planeIconHidden = L.icon({
  iconUrl: './img/planeGraphics/planeN.png',
  iconSize: [1, 1]
});

var planeIconN = L.icon({
  iconUrl: './img/planeGraphics/planeN.png',
  iconSize: [38, 45]
});

var planeIconNNE = L.icon({
  iconUrl: './img/planeGraphics/planeNNE.png',
  iconSize: [38, 45]
});

var planeIconNE = L.icon({
  iconUrl: './img/planeGraphics/planeNE.png',
  iconSize: [38, 45]
});

var planeIconNEE = L.icon({
  iconUrl: './img/planeGraphics/planeNEE.png',
  iconSize: [38, 45]
});

var planeIconE = L.icon({
  iconUrl: './img/planeGraphics/planeE.png',
  iconSize: [38, 45]
});

var planeIconSEE = L.icon({
  iconUrl: './img/planeGraphics/planeSEE.png',
  iconSize: [38, 45]
});

var planeIconSE = L.icon({
  iconUrl: './img/planeGraphics/planeSE.png',
  iconSize: [38, 45]
});

var planeIconSSE = L.icon({
  iconUrl: './img/planeGraphics/planeSSE.png',
  iconSize: [38, 45]
});

var planeIconS = L.icon({
  iconUrl: './img/planeGraphics/planeS.png',
  iconSize: [38, 45]
});

var planeIconSSW = L.icon({
  iconUrl: './img/planeGraphics/planeSSW.png',
  iconSize: [38, 45]
});

var planeIconSW = L.icon({
  iconUrl: './img/planeGraphics/planeSW.png',
  iconSize: [38, 45]
});

var planeIconSWW = L.icon({
  iconUrl: './img/planeGraphics/planeSWW.png',
  iconSize: [38, 45]
});

var planeIconW = L.icon({
  iconUrl: './img/planeGraphics/planeW.png',
  iconSize: [38, 45]
});

var planeIconNWW = L.icon({
  iconUrl: './img/planeGraphics/planeNWW.png',
  iconSize: [38, 45]
});

var planeIconNW = L.icon({
  iconUrl: './img/planeGraphics/planeNW.png',
  iconSize: [38, 45]
});

var planeIconNNW = L.icon({
  iconUrl: './img/planeGraphics/planeNNW.png',
  iconSize: [38, 45]
});

let offAxisIcon = L.icon({
  iconUrl: './img/markers/offAxisMarker.png',
  iconSize: [38, 38]
});

function headingToIcon(heading) {
  const headingNormalized = heading/100;
  let headingIcon;
  if (headingNormalized >= 348.75 || headingNormalized &lt; 11.25) {
    headingIcon = planeIconN;
  } else if (headingNormalized &lt; 33.75) {
    headingIcon = planeIconNNE;
  } else if (headingNormalized &lt; 56.25) {
    headingIcon = planeIconNE;
  } else if (headingNormalized &lt; 78.75) {
    headingIcon = planeIconNEE;
  } else if (headingNormalized &lt; 101.25) {
    headingIcon = planeIconE;
  } else if (headingNormalized &lt; 123.75) {
    headingIcon = planeIconSEE;
  } else if (headingNormalized &lt; 146.25) {
    headingIcon = planeIconSE;
  } else if (headingNormalized &lt; 168.75) {
    headingIcon = planeIconSSE;
  } else if (headingNormalized &lt; 191.25) {
    headingIcon = planeIconS;
  } else if (headingNormalized &lt; 213.75) {
    headingIcon = planeIconSSW;
  } else if (headingNormalized &lt; 236.25) {
    headingIcon = planeIconSW;
  } else if (headingNormalized &lt; 258.75) {
    headingIcon = planeIconSWW;
  } else if (headingNormalized &lt; 281.25) {
    headingIcon = planeIconW;
  } else if (headingNormalized &lt; 303.75) {
    headingIcon = planeIconNWW;
  } else if (headingNormalized &lt; 326.25) {
    headingIcon = planeIconNW;
  } else if (headingNormalized &lt; 348.75) {
    headingIcon = planeIconNNW;
  } else {
    alert(headingNormalized + ' Heading out of bounds');
  }
  return headingIcon;
}

var tempMarkerIcon;
var currentMarkerIcon;
var markerIcon;
/**
 * Initializes the marker objects
 * @returns {undefined}
 */
function initializeMarkers() {
  var tempMarkerImageURL = 'img/markers/tempWPMarker.png';
  var iconSize = [30, 41];
  var iconAnchor = [15, 41];
  var popupAnchor = [0, -41];
  tempMarkerIcon = Leaflet.icon({
    iconUrl: tempMarkerImageURL,
    iconSize, iconAnchor, popupAnchor
  });

  var markerImageURL = 'img/markers/sentWPMarker.png';
  markerIcon = Leaflet.icon({
    iconUrl: markerImageURL,
    iconSize, iconAnchor, popupAnchor
  });

  var currentMarkerImageURL = 'img/markers/currentWPMarker.png';
  currentMarkerIcon = Leaflet.icon({
    iconUrl: currentMarkerImageURL,
    iconSize, iconAnchor, popupAnchor
  });
}

/**
 * Creates a temporary marker on the map
 * @params {Object} e
 * @returns {undefined}
 */
function createTempMarker(e) {
  WaypointActionCreator.addWaypoint(e.latlng.lat, e.latlng.lng);
}

/**
 * Centers the map on the plane's current GPS coordinates
 * @returns {undefined}
 */
function centerOnPlane() {
  var latlng = planeMarker.getLatLng();
  map.panTo([latlng.lat, latlng.lng]);
}

/**
 * Starts ruler on map
 * @returns {undefined}
 */
function startRuler() {
  rulerActive = true;
}

/**
 * Displays distance from original point
 * @param {Object} e
 * @returns {undefined}
 */
function alertDistance(e) {
  if (rulerActive) {
    if (rulerStart === null) {
      rulerStart = {lat: e.latlng.lat, lon: e.latlng.lng};
    } else {
      const meters = geolib.getDistance(
        {latitude: rulerStart.lat, longitude: rulerStart.lon}, 
        {latitude: e.latlng.lat, longitude: e.latlng.lng},
        1, 1
      );
      swal(`${decround(mToFt(meters), 1)} ft`);
      rulerActive = false;
      rulerStart = null;
    }
  }
}

/**
 * Initializes basic features of the map (tile layer, controls, etc.)
 * @returns {undefined}
 */
function mapStarter() {
  L.tileLayer('img/plainWhiteSquare.png', {
    maxZoom: 19,
    minZoom: 15
  }).addTo(map);
  map.doubleClickZoom.disable();
  map.on('click', alertDistance);
  map.on('dblclick', createTempMarker);
  L.easyButton('fa-plane', centerOnPlane).addTo(map);
  L.easyButton('fa-times', resetPlanePath).addTo(map);
  L.easyButton('fa-arrows-h', startRuler).addTo(map);
}

/**
 * Gets the index of a marker object in the array
 * @param {LeafletObject[]} array
 * @param {LeafletObject} object
 * @returns {number} index of object
 * @throws Object Not Found if no matching objects found
 */
function objectIndex(array, object) {
  for (var i = 0; i &lt; array.length; i++) {
    if (Leaflet.stamp(array[i]) === Leaflet.stamp(object)) { return i; }
  }
  throw 'Object Not Found';
}

/**
 * Confirm that the user wants to click on the waypoint
 * Only triggers warning if active and not recently clicked
 * @param {Event} e - drag event with target property
 * @returns {undefined}
 */
function confirmSelection(e) {
  var marker = e.target;
  var latlng = e.target.getLatLng();
  var object_list = marker._popup._content[0] === 'T' ? _old_temp_waypoint_objects : _old_waypoint_objects;
  var wp_list = marker._popup._content[0] === 'T' ? _old_temp_waypoints : _old_waypoints;
  var index = objectIndex(object_list, marker);
  var wp = wp_list[index];
  WaypointActionCreator.updateCellLatLon(wp.index, latlng.lat, latlng.lng);
  WaypointActionCreator.confirmSelectMap(wp.index);
}

/**
 * Sends the current active waypoint
 * @returns {undefined}
 */
function sendWP() {
  WaypointActionCreator.sendWaypoint();
}

function waypointDrag(e) {
  var marker = e.target;
  var object_list = marker._popup._content[0] === 'T' ? _old_temp_waypoint_objects : _old_waypoint_objects;
  var wp_list = marker._popup._content[0] === 'T' ? _old_temp_waypoints : _old_waypoints;
  var index = objectIndex(object_list, marker);
  var wp = wp_list[index];
  var latlng = e.target.getLatLng();
  WaypointActionCreator.updateCellLatLon(wp.index, latlng.lat, latlng.lng);
}

/**
 * Draws a waypoint to the waypointPath and adds a marker to the map
 * @param {Waypoint} waypoint
 * @returns {(LeafletObject|null)} drawn marker
 */
function draw_waypoint(waypoint, current_waypoint) {
  var wpMarkerIcon;
  var wpMarkerText;
  if (waypoint.type === 18) {
    return null;
  } else {
    if (waypoint.isTemp) {
      wpMarkerIcon = tempMarkerIcon;
      wpMarkerText = 'Temp Waypoint';
    } else if (waypoint.index === current_waypoint) {
      wpMarkerIcon = currentMarkerIcon;
      wpMarkerText = 'Waypoint #' + waypoint.index;
    } else {
      wpMarkerIcon = markerIcon;
      wpMarkerText = 'Waypoint #' + waypoint.index;
    }
    var marker = Leaflet.marker([waypoint.lat, waypoint.lon],
      {draggable: true, icon: wpMarkerIcon})
      .addTo(map).bindPopup(wpMarkerText);
    marker.on('click', confirmSelection);
    marker.on('dragend', confirmSelection);
    if (waypoint.isTemp) {
      marker.on('dragstart', () => { dragging = true; });
      marker.on('drag', waypointDrag);
      marker.on('dragend', () => { dragging = false; });
    } else {
      marker.on('dragend', sendWP);
    }
    return marker;
  }
}

/**
 * Resets and draws a waypont path (probably guards against GOTO values)
 * @param {Waypoint[]} waypoints - List of waypoints
 * @returns {undefined}
 */
function draw_path(waypoints) {
  waypointPath.setLatLngs([]);
  var i = 0;
  while (i &lt; waypoints.length) {
    if (waypoints[i].type === 177 &amp;&amp; !(Object.prototype.hasOwnProperty.call(waypoints[i], 'loops_left'))) {
      waypoints[i].loops_left = waypoints[i].lon;
    } else if (waypoints[i].type === 177 &amp;&amp; typeof waypoints[i] === 'number' &amp;&amp; waypoints[i].loops_left > 0) {
      waypoints[i].loops_left -= 1;
      i = waypoints[i].lat;
    } else if (waypoints[i].type === 177 &amp;&amp; typeof waypoints[i] === 'number' &amp;&amp; waypoints[i].loops_left &lt;= 0) {
      delete waypoints[i].loops_left;
      i++;
    } else {
      waypointPath.addLatLng([waypoints[i].lat, waypoints[i].lon]);
      i++;
    }
  }
}

/**
 * Draws a geofence path
 * @param {Waypoint[]} waypoints
 * @returns {LeafletObject}
 */
function draw_geofence(waypoints) {
  let fullMap = [[[90, -180], [90, 180], [-90, 180], [-90, -180]]];
  const fence_points = waypoints.map(wp => [parseFloat(wp.lat), parseFloat(wp.lon)]);
  fullMap = fence_points.length > 0 ? fullMap.concat([waypoints]) : [];
  return L.polygon(fullMap, {color: 'red'}).addTo(map).bindPopup('Geofence');
}

/**
 * Draws an obstacle
 * @param {Obstacle} obstacle
 * @returns {LeafletObject}
 */
function draw_obstacle(obstacle: Object) {
  let is_sphere = Object.prototype.hasOwnProperty.call(obstacle, 'sphere_radius');
  let circle;
  if (is_sphere) {
    if (obstacle.sphere_radius == null) {
      return null;
    }
    circle = L.circle([obstacle.latitude, obstacle.longitude],
      obstacle.sphere_radius, {color: 'blue'}).addTo(map)
      .bindPopup('Sphere, Altitude: ' + obstacle.altitude_msl + ' m');
    return circle;
  } else {
    if (obstacle.cylinder_radius == null) {
      return null;
    }
    circle = L.circle([obstacle.latitude, obstacle.longitude],
      obstacle.cylinder_radius, {color: 'orange'}).addTo(map)
      .bindPopup('Cylinder, Height: ' + obstacle.cylinder_height + ' m');
    return circle;
  }
}

var _old_heading = 0;
var _old_gps = {};
/**
 * Updates the plane marker if the plane's heading or location has changed
 * @returns {undefined}
 */
function updatePlane(gps: GPS, connected: boolean) {
  if (!connected) {
    planeMarker.setIcon(planeIconHidden);
    return;
  }
  if (gps.heading !== undefined &amp;&amp; gps.heading !== _old_heading) {
    planeMarker.setIcon(headingToIcon(gps.heading));
    _old_heading = gps.heading;
  }
  if (!_.isEqual(gps.lat, _old_gps.lat) || !_.isEqual(gps.lon, _old_gps.lon)) {
    planeMarker.setLatLng([gps.lat, gps.lon]);
    planePath.addLatLng([gps.lat, gps.lon]);
  }
}

/**
 * Removes an object from the map (make sure to initialize map first)
 * @params {LeafletObject} layer - Must be a Leaflet ILayer
 * @returns {undefined}
 */
function removeObj(layer) {
  if (layer !== null) {
    map.removeLayer(layer);
  }
}

var _old_waypoints = [];
var _old_waypoint_objects = [];
/**
 * Updates the waypoints if the waypoint list has changed
 * @returns {undefined}
 */
function updateWaypoints(waypoints: Waypoint[], current_waypoint: number, force = false) {
  force = force == undefined ? false : force;
  var different = waypoints.length !== _old_waypoints.length;
  if (!different) {
    for (var i = 0; i &lt; waypoints.length &amp;&amp; !different; i++) {
      different = different ||
        waypoints[i].lat !== _old_waypoints[i].lat ||
        waypoints[i].lon !== _old_waypoints[i].lon ||
        waypoints[i].alt !== _old_waypoints[i].alt ||
        waypoints[i].type !== _old_waypoints[i].type;
    }
  }
  if (force || different) {
    _old_waypoint_objects.forEach(removeObj);
    _old_waypoint_objects = waypoints.map(wp => draw_waypoint(wp, current_waypoint));
  }
  draw_path(waypoints);
  _old_waypoints = waypoints;
}

var _old_temp_waypoints = [];
var _old_temp_waypoint_objects = [];
/**
 * Updates the temp waypoints if the temp waypoint list has changed
 * @returns {undefined}
 */
function updateTempWaypoints(temp_waypoints: Waypoint[], current_waypoint: number) {
  if (dragging) {
    return;
  }
  var different = temp_waypoints.length !== _old_temp_waypoints.length;
  if (!different) {
    for (var i = 0; i &lt; temp_waypoints.length &amp;&amp; !different; i++) {
      different = different ||
        temp_waypoints[i].lat !== _old_temp_waypoints[i].originalLat ||
        temp_waypoints[i].lon !== _old_temp_waypoints[i].originalLon ||
        temp_waypoints[i].alt !== _old_temp_waypoints[i].originalAlt ||
        temp_waypoints[i].type !== _old_temp_waypoints[i].originalType;
    }
  }

  if (different) {
    _old_temp_waypoint_objects.forEach(removeObj);
    _old_temp_waypoint_objects = temp_waypoints.map(wp => draw_waypoint(wp, current_waypoint));
  }
  _old_temp_waypoints = temp_waypoints;
}

var _old_current = -1;
/**
 * Updates the current waypoint if it has changed
 * @returns {undefined}
 */
function updateCurrentWaypoint(current: number) {
  if (_old_waypoint_objects.length > 0) {
    if (_old_current >= 0 &amp;&amp; _old_waypoint_objects[_old_current] != null) {
      _old_waypoint_objects[_old_current].setIcon(markerIcon);
    }
    if (current &lt; _old_waypoints.length &amp;&amp; _old_waypoint_objects[current] != null) {
      _old_waypoint_objects[current].setIcon(currentMarkerIcon);
      _old_current = current;
    }
  }
}

var _old_geofence_objects = [];
/**
 * Updates the geofence
 * @returns {undefined}
 */
function updateGeofences(fence: Point[], enabled: boolean) {
  if (!enabled) {
    _old_geofence_objects.forEach(removeObj);
    _old_geofence_objects = [];
  } else {
    _old_geofence_objects.forEach(removeObj);
    _old_geofence_objects = [draw_geofence(fence)];
  }
}

var _old_obstacles = {stationary: [], moving: []};
var _old_obstacle_objects = {stationary: [], moving: []};
/**
 * Updates the obstacles
 * @returns {undefined}
 */
function updateObstacles(obstacles: ObstacleList) {
  if (!_.isEqual(obstacles, _old_obstacles)) {
    _old_obstacle_objects.stationary.forEach(removeObj);
    _old_obstacle_objects.moving.forEach(removeObj);
    _old_obstacle_objects = {
      stationary: obstacles.stationary.map(draw_obstacle),
      moving: obstacles.moving.map(draw_obstacle)
    };
    _old_obstacles = obstacles;
  }
}

let _old_off_axis = {lat: 0, lon: 0};
function updateOffAxis(off_axis: Point, interopActive: boolean, interopAlive: boolean) {
  if (!interopActive || !interopAlive) {
    offAxisMarker.setIcon(offAxisIconHidden);
    return;
  }
  if (off_axis !== _old_off_axis &amp;&amp; off_axis !== undefined) {
    offAxisMarker.setIcon(offAxisIcon);
  }
  if (!_.isEqual(off_axis.lat, _old_off_axis.lat) || !_.isEqual(off_axis.lon, _old_off_axis.lon)) {
    offAxisMarker.setLatLng([off_axis.lat, off_axis.lon]);
  }
  _old_off_axis = off_axis;
}

/**
 * Default location data, quickly overridden 
 */
var locationsData = {
  'Game_Farm': {
    'leftLon': -76.4650662435,
    'imageURL': 'img/satellites/Game_Farm_Satellite.png',
    'bottomLat': 42.4333928552,
    'topLat': 42.4536610611,
    'rightLon': -76.4376004232
  },
  'Earth_Center': {
    'leftLon': -0.0274658203125,
    'imageURL': 'img/satellites/Earth_Center_Satellite.png',
    'bottomLat': -0.0274658192606,
    'topLat': 0.0274658192606,
    'rightLon': 0.0274658203125
  },
  'Neno_Airfield': {
    'leftLon': -76.62631841015623,
    'centerLon': -76.6125855,
    'imageURL': 'img/satellites/Neno_Airfield_Satellite.png',
    'rightLon': -76.59885258984373,
    'centerLat': 42.44763,
    'bottomLat': 42.4374957409895,
    'topLat': 42.457762619755364
  },
  'SFO_Airport': {
    'leftLon': 149.158355767,
    'imageURL': 'img/satellites/SFO_Airport_Satellite.png',
    'bottomLat': -35.3688493943,
    'topLat': -35.3576502173,
    'rightLon': 149.172088677
  },
  'Cornell_Campus': {
    'leftLon': -76.4950662435,
    'imageURL': 'img/satellites/Cornell_Campus_Satellite.png',
    'bottomLat': 42.4384214463,
    'topLat': 42.4586880256,
    'rightLon': -76.4676004232
  },
  'White Square': {
    'leftLon': 1,
    'imageURL': 'img/plainWhiteSquare.png',
    'bottomLat': -1,
    'topLat': 1,
    'rightLon': -1
  },
  'NAS_Pax': {
    'leftLon': -76.423871799,
    'imageURL': 'img/satellites/NAS_Pax_Satellite.png',
    'bottomLat': 38.2750531654,
    'topLat': 38.2966119005,
    'rightLon': -76.3964059787
  }
};

var locationMap2 = {
  'Neno Airfield': 'Neno_Airfield',
  'NAS Pax': 'NAS_Pax',
  'SFO Airport': 'SFO_Airport',
  'Cornell Campus': 'Cornell_Campus',
  'Game Farm': 'Game_Farm',
  'Earth Center': 'Earth_Center'
};

/**
 * Updates the locations data (image URL, coordinates, etc) and the location map 
 * @params {object} locs
 * @returns {undefined}
 */
export function updateLocations(locs: Object) {
  locationsData = locs;
  for(var name in locs) {
    locationMap2[name.replace(/_/g, ' ')] = name;
  }
}

/**
 * Changes the location of the map to the new location
 * @params {string} location - string of new map location
 * @returns {undefined}
 */
export function changeLocation(location: string) {
  location = locationMap2[location];
  if (location == undefined) location = 'Neno_Airfield';
  var loc = locationsData[location];

  const imageBounds = [[loc.bottomLat, loc.leftLon], [loc.topLat, loc.rightLon]];
  map.setMaxBounds(imageBounds);
  map.setView([(loc.topLat + loc.bottomLat)/2, (loc.leftLon + loc.rightLon)/2]);
  map.doubleClickZoom.disable();
  Leaflet.imageOverlay(loc.imageURL, imageBounds).addTo(map);
}

/**
 * Resets the plane's path (display only)
 * @returns {undefined}
 */
export function resetPlanePath() {
  planePath.setLatLngs([]);
}

/**
 * Redraws all waypoints
 * @returns {undefined}
 */
export function redrawWaypoints(waypoints: Waypoint[], tempWaypoints: Waypoint[], current: number, force: boolean = false) {
  force = force == undefined ? false : force;
  updateWaypoints(waypoints, current, force);
  updateTempWaypoints(tempWaypoints, current);
  updateCurrentWaypoint(current);
}

/**
 * Redraws Fences
 * @param {Point[]} fences
 * @param {boolean} enabled
 */
export function redrawFence(fences: Point[], enabled: boolean) {
  updateGeofences(fences, enabled);
}

/**
 * Redraws all obstacles
 * @param {ObstacleList} obstacles
 * @returns {undefined}
 */
export function redrawObstacles(obstacles: ObstacleList) {
  updateObstacles(obstacles);
}

/**
 * Redraws off-asxis target
 * @param {Point} offAxis
 * @param {boolean} interopActive
 * @param {boolean} interopAlive
 */
export function redrawOffAxis(offAxis: Point, interopActive: boolean, interopAlive: boolean) {
  updateOffAxis(offAxis, interopActive, interopAlive);
}

/**
 * Redraws plane
 * @param {GPS} gps
 * @param {boolean} connected
 * @returns {undefined}
 */
export function redrawPlane(gps: GPS, connected: boolean) {
  updatePlane(gps, connected);
}

/**
 * Causes map to redraw/resize
 * @returns {undefined}
 */
export function mapResize() {
  setTimeout(() => map.invalidateSize(), 100);
}

/**
 * Fully initializes the map
 * @returns {undefined}
 */
export function initializeMap() {
  setMap();
  setMarkers();
  setPaths();
  initializeMarkers();
  mapStarter();
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-actions_CalibrationActionCreator.html">actions/CalibrationActionCreator</a></li><li><a href="module-actions_FenceActionCreator.html">actions/FenceActionCreator</a></li><li><a href="module-actions_InteropActionCreator.html">actions/InteropActionCreator</a></li><li><a href="module-actions_ParametersActionCreator.html">actions/ParametersActionCreator</a></li><li><a href="module-actions_SdaActionCreator.html">actions/SdaActionCreator</a></li><li><a href="module-actions_SettingsActionCreator.html">actions/SettingsActionCreator</a></li><li><a href="module-actions_StatusActionCreator.html">actions/StatusActionCreator</a></li><li><a href="module-actions_TuningActionCreator.html">actions/TuningActionCreator</a></li><li><a href="module-actions_WaypointActionCreator.html">actions/WaypointActionCreator</a></li><li><a href="module-components_Navbar_GoNoGoDropdown.html">components/Navbar/GoNoGoDropdown</a></li><li><a href="module-components_PlaneAction_ModeButton.html">components/PlaneAction/ModeButton</a></li><li><a href="module-components_TuningGuide_TuningUtils.html">components/TuningGuide/TuningUtils</a></li><li><a href="module-constants_ActionTypes.html">constants/ActionTypes</a></li><li><a href="module-constants_ButtonTypes.html">constants/ButtonTypes</a></li><li><a href="module-constants_Frequency.html">constants/Frequency</a></li><li><a href="module-constants_Sites.html">constants/Sites</a></li><li><a href="module-stores_CalibrationStore.html">stores/CalibrationStore</a></li><li><a href="module-stores_FenceStore.html">stores/FenceStore</a></li><li><a href="module-stores_InteropStore.html">stores/InteropStore</a></li><li><a href="module-stores_ParametersStore.html">stores/ParametersStore</a></li><li><a href="module-stores_SdaStore.html">stores/SdaStore</a></li><li><a href="module-stores_SettingsStore.html">stores/SettingsStore</a></li><li><a href="module-stores_StatusStore.html">stores/StatusStore</a></li><li><a href="module-stores_Store.html">stores/Store</a></li><li><a href="module-stores_TuningStore.html">stores/TuningStore</a></li><li><a href="module-stores_WaypointStore.html">stores/WaypointStore</a></li><li><a href="module-utils_ComponentUtils.html">utils/ComponentUtils</a></li><li><a href="module-utils_ConfigData.html">utils/ConfigData</a></li><li><a href="module-utils_DownloadApi.html">utils/DownloadApi</a></li><li><a href="module-utils_LoadApi.html">utils/LoadApi</a></li><li><a href="module-utils_MapUtils.html">utils/MapUtils</a></li><li><a href="module-utils_ReceiveApi.html">utils/ReceiveApi</a></li><li><a href="module-utils_SendApi.html">utils/SendApi</a></li><li><a href="module-utils_TypeValidation.html">utils/TypeValidation</a></li></ul><h3>Classes</h3><ul><li><a href="module-stores_StatusStore.StatusStore.html">StatusStore</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Wed Nov 30 2016 23:25:28 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
